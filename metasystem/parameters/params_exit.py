'''
params_exit.py v0.1 130227

Created on 20120824

@author: edwin

This file contains all possible exit classes, they are instantiated by the
ParamField class (fields.py) and they are used to generate exit signals.

Every exit class MUST:
    * be named exit_* and must be a subclass of _Exit,
    * have a property called <name> that briefly describes what the class does,
    * have a property called <parameters> which is an OrderedDict with
    definitions of all parameters for the class. <parameters> always has a 
    <rule> member, even if if the class has no parameters.
    * have a method called <description> that takes no arguments ad returns a
    string that describes how the algorithm works, this string should contain
    all parameters of the class (excluding <rule>),
    * have a property called <can_prevent_entry> which is a boolean that 
    specifies if the exit can prevent an entry for the same stock and method
    on the same date if it would generate an unconditional signal.
    * have a method called <signal> that returns an ExitSignal instance, the
    <signal> method may take one or more of the following inputs:
        - position          EntrySignal instance
        - date              datetime instance, this signal is generated based on
                            the price data on date, the resulting exit signal is
                            for execution on the next trading day
        - ranked_stock_list list instance that is generated by a _Rank class

NOTE: **kwargs is added to the input of all <signal> methods to future-proof it.
'''
from __future__ import division
from __future__ import absolute_import

import operator
from collections import OrderedDict

from TSB.utils import get_choice
from tradesignal.models import ExitSignal
from channel.models import Channel
from metasystem.parameters.fields import _Param, ModeWidget, ModeListField
from metasystem.parameters.params_market import _Market


class _Exit(_Param):
    '''
    Methods that are common to all exit_* classes go here.
    '''
    IDENTIFIER = 'X'
    reverse = None
    can_prevent_entry = False

    std_mkt = {'widget': ModeWidget,
            'field': ModeListField,
            'format': '{}',
            'doc': 'Market type',
            'verbose': 'Market type', 
            'default': _Market.UP,
            'choices': _Market.MKT_CHOICES,
            }

    def prevent_entry(self, **kwargs):
        '''
        Returns True if this exit can prevent an entry, and generates a signal.
        '''
        return self.can_prevent_entry and self.signal(**kwargs)


# x
class exit_disc(_Exit):
    '''
    Does not return an exit signal - use this for discretionary systems
    '''
    name = 'Discretionary exit'
    parameters = OrderedDict([
            ('rule', _Param.std_rule),
            ])

    def description(self):
        return 'No automatic exits are generated'

    def signal(self, **kwargs):
        return None



# TIME BASED EXITS:

# td
class exit_d(_Exit):
    '''
    Return an exit signal after <nd> days on the market. If <nd> is 1, the exit
    is for the next trading day. Depending on the value of
    <at> the exit signal may be conditional or unconditional. In case of a 
    conditional signal the reference price is todays open, high, low or close, 
    as specified by <pr>.
    '''
    name = 'Daily exit'
    parameters = OrderedDict([
            ('rule', _Param.std_rule),
            ('nd', dict(_Param.std_nd, **{
                'doc': 'Number of days on the market',
                'range': (1, 20),
                'default': 1,
                })),
            ('at', _Param.std_all_at),
            ('pr', _Param.std_price),
            ])

    def description(self):
        if self.repr('nd') == '1':
            when = 'tomorrow'
        else:
            when = 'after {} days on the market'.format(self.repr('nd'))
        if self.repr('at') == get_choice(self.AT_CHOICES, self.STOP) or (
                self.repr('at') == get_choice(self.AT_CHOICES, self.LIMIT)):
            price = ' = todays {}'.format(self.repr('pr'))
        else:
            price = ''
        return 'Exit {} at {}{}.'.format(when, self.repr('at'), price)

    def signal(self, date, position, **kwargs):
        if position.stock.price.close.delta(position.date_entry, date) < self.nd - 1:
            return None
        if self.at == self.OPEN or self.at == self.CLOSE:
            price = None
        elif self.pr == self.HIGH:
            price = position.stock.price.high[date]
        elif self.pr == self.LOW:
            price = position.stock.price.low[date]
        elif self.pr == self.OPEN:
            price = position.stock.price.open[date]
        elif self.pr == self.CLOSE:
            price = position.stock.price.close[date]
        return ExitSignal(position, self.rule, self.at, price)


# tw
class exit_wk(_Exit):
    '''
    Returns an unconditional exit signal if the current trading day is in a
    new week. Depending on the setting of <at> the exit may be at the close on 
    Friday or the open on Monday.
    '''
    name = 'Unconditional exit at the end of the week'
    parameters = OrderedDict([
            ('rule', _Param.std_rule),
            ('at', _Param.std_at),
            ])

    def description(self):
        if self.repr('at') == get_choice(self.AT_CHOICES, self.OPEN):
            when = 'on the first trading day'
        elif self.repr('at') == get_choice(self.AT_CHOICES, self.CLOSE):
            when = 'on the last trading day'
        else:
            when = 'at the end'
        return 'Exit {} of the week at {}.'.format(when, self.repr('at'))

    def signal(self, date, position, **kwargs):
        price = position.stock.price
        next_trading_day = price.close.get_date(date, 1)
        if ((self.at == self.OPEN) and (date.isocalendar()[1] != 
                next_trading_day.isocalendar()[1])) or (
                (self.at == self.CLOSE) and (next_trading_day.isocalendar()[1] 
                != price.close.get_date(date, 2).isocalendar()[1])):
            return ExitSignal(position, self.rule, self.at)


# tm
class exit_mt(_Exit):
    '''
    Returns an unconditional exit signal if the next trading day is in a new
    month. Depending on the setting of <at>, the exit may be at the close of the
    last trading day of the month or the open of the first trading day of the
    month.
    '''
    name = 'Unconditional exit at the end of the month'
    parameters = OrderedDict([
            ('rule', _Param.std_rule),
            ('at', _Param.std_at),
            ])

    def description(self):
        if self.repr('at') == get_choice(self.AT_CHOICES, self.OPEN):
            when = 'on the first trading day'
        elif self.repr('at') == get_choice(self.AT_CHOICES, self.CLOSE):
            when = 'on the last trading day'
        else:
            when = 'at the end'
        return 'Exit {} of the month at {}.'.format(when, self.repr('at'))

    def signal(self, date, position, **kwargs):
        price = position.stock.price
        if ((self.at == 'o') and (
                date.month != price.close.get_date(date, 1).month)) or (
                (self.at == 'c') and (price.close.get_date(date, 1).month != 
                price.close.get_date(date, 2).month)):
            return ExitSignal(position, self.rule, self.at)



# MARKET TYPE EXITS:


# mtc
class exit_mty(_Exit):
    '''
    Returns an unconditional exit signal depending on the value of mt:
        ANY - if the market type is not this methods market type
        else: if the market type is mt 
    '''
    name = 'Market type change'
    parameters = OrderedDict([
            ('rule', _Param.std_rule),
            ('at', _Param.std_at),
            ('sw', _Param.std_switch),
            ('mt', _Exit.std_mkt),
            ])

    def description(self):
        if self.repr('sw') == get_choice(self.SWITCH_CHOICES, self.ON):
            if self.repr('mt') == get_choice(_Market.MKT_CHOICES, _Market.ANY):
                return 'Exit at {} if the market type is not this method\'s.'.\
                        format(self.repr('at'))
            else:
                return 'Exit at {} if the market type is {}.'.format(
                        self.repr('at'), self.repr('mt'))
        else:
            return 'This exit is inactive'

    def signal(self, date, position, method_list, **kwargs):
        if (self.sw == self.OFF) or ((self.mt == _Market.ANY) and
                (any(m.markettype == position.method.markettype for m in
                method_list))) or ((self.mt != _Market.ANY) and
                (all(m.markettype != self.mt for m in method_list))):
            return None
        else:
            return ExitSignal(position, self.rule, self.at)



# INDICATOR BASED EXITS:


# ibo
class exit_bo(_Exit):
    '''
    Returns an entry signal if <stock>'s close on <date> is <op> its <n_days>
    moving average + <mpl> * the <n_days> atr.
    This signal *will* be executed on the next trading day.
    '''
    name = 'Breakout exit'
    can_prevent_entry = True
    parameters = OrderedDict([
            ('rule', _Param.std_rule),
            ('at', _Param.std_at),
            ('ndm', dict(_Param.std_nd, **{
                'verbose': 'No. of days for the MA',
                })),
            ('op', _Param.std_op),
            ('mpl', dict(_Param.std_flt, **{
                 'verbose': 'Multiplier for ATR',
                 'default': 1, 
                 'range': (-5., 5.),
                 })),
            ('nda', dict(_Param.std_nd, **{
                'verbose': 'No. of days for the ATR',
                'default': 10,
                })),
            ])

    def description(self):
        return 'Exit tomorrow at {} if todays close is {} (the {} day simple'\
                ' moving average plus {} times the {} day average true range)'\
                .format(self.repr('at'), self.repr('op'), self.repr('ndm'), 
                self.repr('mpl'), self.repr('nda'))

    def signal(self, date, position, **kwargs):
        price = position.stock.price
        if getattr(operator, self.op)(price.close[date], 
                price.close.sma(self.ndm, date) + self.mpl *
                price.atr(self.nda, date)):
            return ExitSignal(position, self.rule, self.at)


# iwr
class exit_wr(_Exit):
    '''
    Returns an exit signal if <stock>'s Williams R on <date> is <op> the value
    of <th>, where the operator <op> is 'gt'or 'lt'. The entry may be at open
    or close, depending on the value of 'at'.
    This signal *will* be executed on the next trading day.
    '''
    name = 'Williams R exit.'
    can_prevent_entry = True
    parameters = OrderedDict([
            ('rule', _Param.std_rule),
            ('nd', _Param.std_nd),
            ('op', _Param.std_op),
            ('th', dict(_Param.std_int, **{
                'verbose': 'Threshold',
                'default': -20,
                'range': (-99, -1),
                'doc'  : 'Threshold for WR',
                })),
            ('at', _Param.std_at),
            ])

    def description(self):
        return 'Exit tomorrow at {} if todays {} day WR is {} {}.'.format(
                self.repr('at'), self.repr('nd'), self.repr('op'), 
                self.repr('th'))

    def signal(self, date, position, **kwargs):
        wr = position.stock.price.wr(self.nd, date)
        if getattr(operator, self.op)(wr, self.th):
            return ExitSignal(position, self.rule, self.at)


# ima
class exit_ma(_Exit):
    '''
    Generates an exit signal if <stock>'s close price on <date> is <op> its 
    <nd> day moving average, where the operator <op> is 'gt'or 'lt'. The exit
    may be at open or close, depending on the value of 'at'. 
    This signal *will* be executed on the next trading day.
    '''
    name = 'Moving average crossover exit.'
    can_prevent_entry = True
    parameters = OrderedDict([
            ('rule', _Param.std_rule),
            ('nd', _Param.std_nd),
            ('op', _Param.std_op),
            ('at', _Param.std_at),
            ])

    def description(self):
        return 'Exit tomorrow at {} if todays close price is {} the {} day '\
                'simple moving average.'.format(self.repr('at'), 
                self.repr('op'), self.repr('nd'))

    def signal(self, date, position, **kwargs):
        close = position.stock.price.close
        if getattr(operator, self.op)(close[date], close.sma(self.nd, date)):
            return ExitSignal(position, self.rule, self.at)



# PRICE BASED EXITS:


class exit_psl(_Exit):
    '''
    Generates a stop loss at the signal day low (day before the entry). 
    '''
    name = 'Stop loss at low of day before entry'
    parameters = OrderedDict([
            ('rule', _Param.std_rule),
            ])

    def description(self):
        return 'Exit tomorrow if at any time the price goes below the signal '\
                'day low '

    def signal(self, position, **kwargs):
        price = position.stock.price.low.offset(position.date_entry, -1)
        if position.method.direction == position.method.LONG:
            at = self.STOP
#            price = position.price_entry * (1 - factor)
        else: # short sl  (long tp)
            at = self.LIMIT
#            price = position.price_entry * (1 + factor)
#        at = self.STOP
        return ExitSignal(position, self.rule, at, price)



# pl
class exit_sl(_Exit):
    '''
    Generates an exit signal for a stop loss. 
    This signal *may* be executed on the next trading day.
    '''
    name = 'Stop loss at percentage from the entry.'
    reverse = 'tp'
    parameters = OrderedDict([
            ('rule', _Param.std_rule),
            ('pc', dict(_Param.std_pc, **{
                'range': (0.1, 100.),
                })),
            ])

    def description(self):
        return 'Exit tomorrow if at any time the loss would be greater than '\
                '{}.'.format(self.repr('pc'))

    def signal(self, position, **kwargs):
        factor = 0.01 * self.pc
        if (position.method.direction == position.method.LONG) == (
                self.reverse == 'tp'): # long sl (shrt tp)
            at = self.STOP
            price = position.price_entry * (1 - factor)
        else: # short sl  (long tp)
            at = self.LIMIT
            price = position.price_entry * (1 + factor)
        return ExitSignal(position, self.rule, at, price)


# pp
class exit_tp(exit_sl):
    '''
    Generates an exit signal for a profit take.
    This signal *may* be executed on the next trading day.
    '''
    name = 'Take profit at percentage from the entry.'
    reverse = 'sl'

    def description(self):
        return 'Exit tomorrow if at any time the profit would be greater than'\
                ' {}.'.format(self.repr('pc'))


# pts
class exit_tsl(_Exit):
    '''
    Generates an exit signal for a trailing stop loss. In case of a long trade
    a stop is placed <pc>% below the high since entry and for short trades
    a limit is placed <pc>% above the low since entry.
    This signal *may* be executed on the next trading day.
    '''
    name = 'Trailing stop loss at percentage from the extreme since entry.'
    reverse = 'ttp'
    parameters = OrderedDict([
            ('rule', _Param.std_rule),
            ('pc', dict(_Param.std_pc, **{
                'range': (0.1, 100.),
                })),
            ])

    def description(self): 
        return 'Exit tomorrow at market if the profit would be less than {} '\
                'below the highest profit since entry.'.format(self.repr('pc'))

    def initialise(self, **kwargs):
        self.factor  = 0.01 * self.pc
        return {}

    def signal(self, date, position, **kwargs):
        if (position.method.direction == position.method.LONG) == (
                                            self.reverse == 'ttp'): # long tsl
            at = self.STOP
            high = max(position.stock.price.high[position.date_entry: date])
            price = (1 - self.factor) * high
        else: # short tsl  (long ttp)
            at = self.LIMIT
            low = min(position.stock.price.low[position.date_entry: date])
            price = (1 + self.factor) * low
        return ExitSignal(position, self.rule, at, price)


# ptp
class exit_ttp(exit_tsl):
    '''
    Generates an exit signal for a trailing profit take. In case of a long 
    trade a limit is placed <pc>% above the low since entry and for short 
    trades a stop is placed <pc>% below the high since entry.
    This signal *may* be executed on the next trading day.
    '''
    name = 'Trailing profit take at percentage from the extreme since entry.'
    reverse = 'tsl'

    def description(self): 
        return 'Exit tomorrow at market if the profit would be more than {} '\
                'above the lowest profit since entry.'.format(self.repr('pc'))



# RANK BASED EXITS:


# rtn
class exit_rnk(_Exit):
    '''
    Generates an exit signal if the stock is not in the top <np> of the stock 
    ranking.
    This exit should be used in combination with the equity_npos equity model,
    although it can function without it.
    This signal *will* be executed on the next trading day.
    '''
    name = 'Rank based exit.'

    parameters = OrderedDict([
            ('rule', _Param.std_rule),
            ('np', dict(_Param.std_int, **{
                'verbose': 'Lowest allowed rank',
                'default': 5, 
                'range': (1,20),
                })),
            ('at', _Param.std_at),
            ])

    def description(self):
        return 'Exit tomorrow at {} if todays rank is not in the top {}.'\
                .format(self.repr('at'), self.repr('np'))

    def signal(self, ranked_stock_list, position, **kwargs):
        if not getattr(self, 'n_pos', None):
            # ensure np > np of the equitymodel (if it exists)
            if getattr(position.method.metasystem.equitymodel, 'np'):
                self.n_pos = max(self.np, 
                        position.method.metasystem.equitymodel.np)
            else:
                self.n_pos = self.np
        if not any([r[0] == position.stock for r in 
                ranked_stock_list[:self.n_pos]]):
            return ExitSignal(position, self.rule, self.at)



# CHANNEL BASED EXITS:


# ca
class exit_cha(_Exit):
    '''
    Generates an exit signal if the <lb> channel angle is <op> the <th>.
    '''
    name = 'Angle value'

    parameters = OrderedDict([
            ('rule', _Param.std_rule),
            ('lb', _Param.std_lb),
            ('op', _Param.std_op),
            ('th', dict(_Param.std_flt, **{
                'verbose': 'Angle threshold',
                'default': 0.,
                'range': (-100., 100.),
                'doc'  : 'Threshold for channel angle',
                })),
            ('at', _Param.std_at),
            ])

    can_prevent_entry = True

    def description(self): 
        return 'Exit tomorrow at {} if todays {} channel angle is {} {}.'.\
                format(self.repr('at'), self.repr('lb'), self.repr('op'), 
                self.repr('th'))

    def signal(self, date, position, **kwargs):
        channel = position.stock.price.channel.angle(self.lb)[date]
        if getattr(operator, self.op)(channel, self.th):
            return ExitSignal(position, self.rule, self.at)



class exit_cwm(_Exit):
    '''
    '''
    name = 'ChW(1m)==ChWmin'
    parameters = OrderedDict([
            ('rule', _Param.std_rule),
            ('at', _Param.std_at),
            ])

    def description(self):
        return 'Exit tomorrow at {} if todays 1 month normalised channel '\
                'width is not the lowest of all widths.'.format(self.repr('at'))

    def signal(self, date, position, **kwargs):
        if (position.stock.price.channel.width_n(Channel.MONTH)[date] != 
                position.stock.price.channel.width_min()[date]):
            return ExitSignal(position, self.rule, self.at)



class exit_ct(_Exit):
    '''
    Generates an exit signal if price goes above the top channel line.
    '''
    name = 'Channel - top line'

    parameters = OrderedDict([
            ('rule', _Param.std_rule),
            ('lb', _Param.std_lb),
            ('ra', dict(_Param.std_switch, **{'doc':
                'Determines if the top line is adjusted in the direction of '\
                'the trade (it will never be adjusted against it).',
                'verbose': 'Ratchet',
                })),
            ])

    def description(self): 
        ra = ''
        if self.repr('ra') == get_choice(self.SWITCH_CHOICES, self.ON):
            ra = ' Adjust the top line in the direction of the trade.'
        return 'Exit tomorrow at market if the price goes above the top '\
                'line of the {} channel.{}'.format(self.repr('lb'), ra)

    def signal(self, date, position, **kwargs):
        price = position.stock.price.channel.stoptop(self.lb, date, 
                position.date_entry)
        if self.ra:
            alt_price = position.stock.price.channel.stoptop(self.lb, date)
        if position.method.direction == position.method.LONG:
            at = self.LIMIT
            if self.ra:
                price = max(price, alt_price)
        else: # SHORT
            at = self.STOP
            if self.ra:
                price = min(price, alt_price)
        return ExitSignal(position, self.rule, at, price)


class exit_ctr(exit_ct):
    '''
    Generates an exit signal if price goes above the top channel line, where
    the lookback of the channel is taken from the rank of this method.
    '''
    name = 'Channel (rank) - top line'

    parameters = OrderedDict([
            ('rule', _Param.std_rule),
            ('ra', dict(_Param.std_switch, **{'doc':
                'Determines if the top line is adjusted in the direction of '\
                'the trade (it will never be adjusted against it).',
                'verbose': 'Ratchet',
                })),
            ])

    def description(self): 
        ra = ''
        if self.repr('ra') == get_choice(self.SWITCH_CHOICES, self.ON):
            ra = ' Adjust the top line in the direction of the trade.'
        return 'Exit tomorrow at market if the price goes above the top '\
                'line of the rank channel.{}'.format(ra)

    def signal(self, date, position, **kwargs):
        self.lb = position.method.rank.lb
        return super(exit_ctr, self).signal(date, position, **kwargs)


#class exit_ctha(exit_ct):
#    '''
#    Generates an exit signal if price goes above the top channel line, where
#    the lookback of the channel that has the highest angle is taken.
#    '''
#    name = 'Channel (rank) - top line'
#
#    parameters = OrderedDict([
#            ('rule', _Param.std_rule),
#            ('ra', dict(_Param.std_switch, **{'doc':
#                'Determines if the top line is adjusted in the direction of '\
#                'the trade (it will never be adjusted against it).',
#                'verbose': 'Ratchet',
#                })),
#            ])
#
#    def description(self): 
#        ra = ''
#        if self.repr('ra'):
#            ra = ' Adjust the top line in the direction of the trade.'
#        return 'Exit tomorrow at market if the price goes above the top '\
#                'line of the rank channel.{}'.format(ra)
#
#    def signal(self, date, position, **kwargs):
#        self.lb = position.method.rank.lb
#        return super(exit_ctr, self).signal(date, position, **kwargs)
#
#
#class exit_ctls(exit_ct):
#    '''
#    Generates an exit signal if price goes above the top channel line, where
#    the lookback of the channel that has the lowest stop loss is taken.
#    '''
#    name = 'Channel (rank) - top line'
#
#    parameters = OrderedDict([
#            ('rule', _Param.std_rule),
#            ('ra', dict(_Param.std_switch, **{'doc':
#                'Determines if the top line is adjusted in the direction of '\
#                'the trade (it will never be adjusted against it).',
#                'verbose': 'Ratchet',
#                })),
#            ])
#
#    def description(self): 
#        ra = ''
#        if self.repr('ra'):
#            ra = ' Adjust the top line in the direction of the trade.'
#        return 'Exit tomorrow at market if the price goes above the top '\
#                'line of the rank channel.{}'.format(ra)
#
#    def signal(self, date, position, **kwargs):
#        self.lb = position.method.rank.lb
#        return super(exit_ctr, self).signal(date, position, **kwargs)


class exit_cb(_Exit):
    '''
    Generates an exit signal if price goes below the top channel line.
    '''
    name = 'Channel - bottom line'

    parameters = OrderedDict([
            ('rule', _Param.std_rule),
            ('lb', _Param.std_lb),
            ('ra', dict(_Param.std_switch, **{'doc':
                'Determines if the bottom line is adjusted in the direction '\
                'of the trade (it will never be adjusted against it).',
                'verbose': 'Ratchet',
                })),
            ])

    def description(self): 
        ra = ''
        if self.repr('ra') == get_choice(self.SWITCH_CHOICES, self.ON):
            ra = ' Adjust the bottom line in the direction of the trade.'
        return 'Exit tomorrow at market if the price goes below the bottom '\
                'line of the {} channel.{}'.format(self.repr('lb'), ra)

    def signal(self, date, position, **kwargs):
        price = position.stock.price.channel.stopbottom(self.lb, date, 
                position.date_entry)
        if self.ra:
            alt_price = position.stock.price.channel.stopbottom(self.lb, date)
        if position.method.direction == position.method.LONG:
            at = self.STOP
            if self.ra:
                price = max(price, alt_price)
        else: # SHORT
            at = self.LIMIT
            if self.ra:
                price = min(price, alt_price)
        return ExitSignal(position, self.rule, at, price)


class exit_cbr(exit_cb):
    '''
    Generates an exit signal if price goes below the bottom channel line, where
    the lookback of the channel is taken from the rank of this method.
    '''
    name = 'Channel (rank) - bottom line'

    parameters = OrderedDict([
            ('rule', _Param.std_rule),
            ('ra', dict(_Param.std_switch, **{'doc':
                'Determines if the bottom line is adjusted in the direction '\
                'of the trade (it will never be adjusted against it).',
                'verbose': 'Ratchet',
                })),
            ])

    def description(self): 
        ra = ''
        if self.repr('ra') == get_choice(self.SWITCH_CHOICES, self.ON):
            ra = ' Adjust the bottom line in the direction of the trade.'
        return 'Exit tomorrow at market if the price goes below the bottom '\
                'line of the rank channel.{}'.format(ra)

    def signal(self, date, position, **kwargs):
        self.lb = position.method.rank.lb
        return super(exit_cbr, self).signal(date, position, **kwargs)



# OBSOLETE:


class exit_chma(_Exit):
    '''
    Generates an exit signal if at least one channel angle between 0 and <lb>
    (inclusive) is <op> 0.
    '''
    name = 'OBSOLETE - use market instead Multiple Angle values'

    parameters = OrderedDict([
            ('rule', _Param.std_rule),
            ('lb', _Param.std_lb),
            ('op', _Param.std_op),
            ('at', _Param.std_at),
            ])

    can_prevent_entry = True

    def description(self): 
        return 'Exit tomorrow at {} if any channel angle up to {} is {} 0.'.\
                format(self.repr('at'), self.repr('lb'), self.repr('op'))

    def signal(self, date, position, **kwargs):
        for lb in Channel.LOOKBACKS:
            if lb <= self.lb and getattr(operator, self.op)(
                        position.stock.price.channel.angle(lb)[date], 0):
                return ExitSignal(position, self.rule, self.at)


class exit_rs(_Exit):
    '''
    Generates an exit signal for a rising stop. 
    '''
    name = 'OBSOLETE Rising stop by channel angle'

    parameters = OrderedDict([
            ('rule', _Param.std_rule),
            ('lb', _Param.std_lb),
            ])

    def description(self): 
        return 'Exit tomorrow at market if the price goes below the bottom '\
                'line of the {} channel.'.format(self.repr('lb'))

    def signal(self, date, position, **kwargs):
        price = position.stock.price.channel.stoploss(self.lb, date, 
                position.date_entry)
        at = self.STOP
        return ExitSignal(position, self.rule, at, price)



class exit_rsr(exit_rs):
    '''
    USES THE RANK lb
    '''
    name = 'OBSOLETE Rising stop by rank channel angle'

    parameters = OrderedDict([
            ('rule', _Param.std_rule),
            ])

    def description(self): 
        return 'Exit tomorrow at market if the price goes below the bottom '\
                'line of the ranks channel.'

    def signal(self, date, position, **kwargs):
        self.lb = position.method.rank.lb
        return super(exit_rsr, self).signal(date, position, **kwargs)



class exit_tc(_Exit):
    '''
    Generates a profit taking exit signal for the top channel line.
    Long
    '''
    name = 'OBSOLETE Top channel'

    parameters = OrderedDict([
            ('rule', _Param.std_rule),
            ('lb', _Param.std_lb),
            ])

    def description(self): 
        return 'Exit tomorrow at market if the price goes beyond the top '\
                'line of the {} channel.'.format(self.repr('lb'))

    def signal(self, date, position, **kwargs):
        if position.method.direction == position.method.LONG:
            at = self.LIMIT
        else:
            at = self.STOP
        price = position.stock.price.channel.top(self.lb)[date]
        return ExitSignal(position, self.rule, at, price)



class exit_tcr(exit_tc):
    '''
    Generates an exit signal for the top channel line, using the rank channel
    lookback.
    '''
    name = 'OBSOLETE Top rank channel'

    parameters = OrderedDict([
            ('rule', _Param.std_rule),
            ])

    def description(self): 
        return 'Exit tomorrow at market if the price goes beyond the top '\
                'line of the rank channel.'

    def signal(self, date, position, **kwargs):
        self.lb = position.method.rank.lb
        return super(exit_tcr, self).signal(date, position, **kwargs)


class exit_mkt(_Exit):
    '''
    Returns an unconditional exit signal if there was a change in market type.
    '''
    name = 'OBSOLETE Unconditional exit when the market type changes'
    parameters = OrderedDict([
            ('rule', _Param.std_rule),
            ('at', _Param.std_at),
            ('sw', _Param.std_switch),
            ])

    def description(self):
        if self.repr('sw') == get_choice(self.SWITCH_CHOICES, self.ON):
            return 'Exit at {} if the market type has changed.'.format(
                    self.repr('at'))
        else:
            return 'This exit is inactive'

    def signal(self, date, position, method_list, **kwargs):
        if self.sw == self.ON:
            for method in method_list:
                if position.method == method:
                    return None
            return ExitSignal(position, self.rule, self.at)





class exit_test(_Exit):
    '''
    This class is for testing, don't modify or delete.
    '''
    name = 'Test'

    parameters = OrderedDict([
            ('rule', _Param.std_rule),
            ])

    def description(self):
        return 'Test {}'.format(self.repr('nd'))

    def initialise(self, **kwargs):
        return {}

    def signal(self, position, **kwargs):
        return ExitSignal(position, self.rule, _Param.OPEN)
